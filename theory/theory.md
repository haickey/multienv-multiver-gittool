# 前言

这套方案的核心观点是不要把git的commit顺序当成版本的顺序，而是进一步的细分，将commit中的每一个文件的修改部分当成是一种带有版本先后顺序。git的commit不再是顺序的向下延伸不断前进，而是作为一个个独立的节点，就像是海滩上一个个的贝壳，是零碎的存在，彼此间联系甚微，将某个文件放到另外一个版本上的行为，更加像是在海滩上挑选贝壳，将他们扔到一个桶中，而这个桶就是下一个环境。

在这种想法的催生下，可以衍生出一种畸形的git使用方式，这种方式可以适应多个环境下有多个互不相关的版本的问题。用人类阅读的语言就是说可以同时开发3-4个特性同时开发，却在完全先后顺序的条件下登录不同的环境，当然，其中的版本关联问题也是需要处理的。

想法基于主干分支开发，对CI（持续集成）的过程友好，并且在大型项目中，也建议尽早进行合并。

当然，因为使用极端特殊，这个文档是和分享作为将过程脚本化，自动化的依据存在的，使用这个方案管理的难度以及复杂度和其他的git方案相比是量级差距的提升，甚至需要使用数据库维护信息。这个文档更加接近预想手册。

# 仅仅2个环境的情况

下面我们将情况简化到只有2个环境，为了方便一个环境成为SIT（系统集成）另一个成为PRD（生产环境），之后我们会从这里面推到出3个乃至更多环境应该如何进行调度和使用。

## 完全无关联的情况，3个特性同时开发

这里我们的假设是3个特性将同时进行开发，但是他们并没有编辑到同一个文件，也就没有任何合并冲突问题出现。

这是最简单的情况，主要演示的是如何在这种思想下进行从开发者本地集成到公共环境、如何将环境安装到另外一个版本上。这一节探讨的问题很弱智，但是麻烦看一看，因为是后面一些情况推演的基础。

### 2条主干，没有所谓的master

### 如何开发，从DEV到SIT，这里只是建议

如何开发，如何merge，如何继续开发，如何push

### 从一个环境到另一个环境，也是建议


