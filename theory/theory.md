# 前言

这套方案的核心观点是不要把git的commit顺序当成版本的顺序，而是进一步的细分，将commit中的每一个文件的修改部分当成是一种带有版本先后顺序。git的commit不再是顺序的向下延伸不断前进，而是作为一个个独立的节点，就像是海滩上一个个的贝壳，是零碎的存在，彼此间联系甚微，将某个文件放到另外一个版本上的行为，更加像是在海滩上挑选贝壳，将他们扔到一个桶中，而这个桶就是下一个环境。

在这种想法的催生下，可以衍生出一种畸形的git使用方式，这种方式可以适应多个环境下有多个互不相关的版本的问题。用人类阅读的语言就是说可以同时开发3-4个特性同时开发，却在完全先后顺序的条件下登录不同的环境，当然，其中的版本关联问题也是需要处理的。

想法基于主干分支开发，对CI（持续集成）的过程友好，并且在大型项目中，也建议尽早进行合并。

当然，因为使用极端特殊，这个文档是和分享作为将过程脚本化，自动化的依据存在的，使用这个方案管理的难度以及复杂度和其他的git方案相比是量级差距的提升，甚至需要使用数据库维护信息。这个文档更加接近预想手册。

# 仅仅2个环境的情况

下面我们将情况简化到只有2个环境，为了方便一个环境成为SIT（系统集成）另一个成为PRD（生产环境），之后我们会从这里面推到出3个乃至更多环境应该如何进行调度和使用。

## 完全无关联的情况，3个特性同时开发

这里我们的假设是3个特性将同时进行开发，但是他们并没有编辑到同一个文件，也就没有任何合并冲突问题出现。

这是最简单的情况，主要演示的是如何在这种思想下进行从开发者本地集成到公共环境、如何将环境安装到另外一个版本上。这一节探讨的问题很弱智，但是麻烦看一看，因为是后面一些情况推演的基础。

### 现在的环境

如先前所述，我们假设有两个环境，sit和prd环境，这两个环境是主线环境，我们需要针对这两个环境进行基于特性的版本控制。

![image-20200908003355308](F:\git研发\multienv-multiver-gittool\theory\picture\image-20200908003118079.png)

我们假设当前的环境如<u>*上*</u>*<u>图</u>*所示，**ft01**代表了我们开发的东西属于**特性01**，后面的是表明这个合并到主分支上面的commit信息。~~原谅我很没有创意的用古诗词作为讲解道具，因为这东西没有什么阅读障碍。~~

目前的状态开发如下图，登鹳雀楼完成了，江雪完成了第一段。

![image-20200908003948035](F:\git研发\multienv-multiver-gittool\theory\picture\image-20200908003751286.png)

### 特性如何开发，从DEV到SIT

下面我们将用开发者视角，开发一个新的特性——塞下曲，属于feature03.

下面是简易的开发步骤

第一步，在环境最新的版本上开启一个分支。

```
git checkout -b ft03
```

第二步，在你的特性分支上任意开发，随意commit，如果乐意，将future上传也是可以的。

```
git add -u .
git commit -m '你想提交什么请随意，在你的特性分支上受限制'
git push
```

你的作品完成了第一句话` 月黑雁飞高，单于夜遁逃。` 下图是你在**你的分支**上commit完成的结果

![image-20200908005238906](F:\git研发\multienv-multiver-gittool\theory\picture\image-20200908005238906.png)

![image-20200908004918637](F:\git研发\multienv-multiver-gittool\theory\picture\image-20200908004918637.png)

这个时候你准备将你的成果添加到sit环境中，不过还记得江雪吗？它完成了，并且先你一步提交，不过不要紧，你们在不同的文件上，并不会产生版本冲突。这个时候的环境开启来是这样的

![image-20200908005542841](F:\git研发\multienv-multiver-gittool\theory\picture\image-20200908005542841.png)

#### 如何合并回主线，这是重头戏！！！

你想要的将你的代码合并到主线上。

所以，首先用merge确保一下你和环境间的冲突吧，这一步也是处理你和大环境之间的版本关联的。

```
git merge sit
```

完成后情况如下图

![image-20200908010256999](F:\git研发\multienv-multiver-gittool\theory\picture\image-20200908010256999.png)



其实并没有版本关联（肯定的），不过这个时候江雪已经到了你的分支上了，然后尽快将你的分支merge进入sit环境，这样才算你的代码进入主线，不过注意，合并回主线的merge命令需要特别对待了

```
git checkout sit
git merge --no-ff ft03
```

记住，使用merge的no-ff 模式，区别可以看下图

![image-20200908010657620](F:\git研发\multienv-multiver-gittool\theory\picture\image-20200908010657620.png)

同时注意，commit的名字也要符合之前说的要求**ftxx-commit的内容**

如果只关注sit的主干部分，完全忽视ft03分支，效果其实如下图

![image-20200908011126181](F:\git研发\multienv-multiver-gittool\theory\picture\image-20200908011126181.png)

#### 后日谈

如果要持续集成，尽量避免使用分支。然而因为这种畸形的使用merge，可以做到尽早合并，尽快合并。作者更加意见每天下班前，如果自己的dev环境可靠，就进行一次合并到主干的操作，保证提后不要出现太多的版本关联问题。

当然，一个future并不是合并完就死掉了，它还可以继续进行接下来的开发，然后将主干融入再融合进入主干，比如这样。

![image-20200908012124234](F:\git研发\multienv-multiver-gittool\theory\picture\image-20200908012124234.png)

这种多段多次的merge是我们的交流基础和共识，如果你认同了这个观点，下面的故事才可能发生，不然就会有无穷尽的争论了，接下来的所有commit，我们都认为可能是大量的复杂文件提交以及一个最终版本处理之后才提交的。

这个git模型适合的是极度麻烦的环境——拥有多个环境，每个环境还有各自的版本，每个环境间需要的特性甚至前后顺序都是颠倒错位的。

极端的环境造就极端的生物，这种git的管理甚至需要使用到数据库以及脚本才能勉强运行，但是它确实适合应对这种极端的环境要求。



### 从一个环境到另一个环境，也是建议



## 发生冲突的情况



## 发生冲突特性移动环境前后颠倒的情况

